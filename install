#!/usr/bin/env bash

#set -x

# required and default variables
NOERR=0
FIND_PATH=1


# Error logging
function _err {
    let NOERR=NOERR+1
}


# using only Python 2.7, for now ...
function _check_req_pyver {

    # see if correct python version already set in pyenv
    local pyvers="$(pyenv versions)"
    [[ "$pyvers" == *"* $PYBRAT_PROG "* ]] && return

    # see if virtualenv in pyenv but not set to local
    if [[ "$pyvers" == *"$PYBRAT_PROG"* ]]; then
       pyenv local $PYBRAT_PROG
       return
    fi

    echo "==> 'pybrat' requires a pyenv virtualenv with Python-${REQ_PYVER}."
    read -p "Bootstrap Python-${REQ_PYVER} with 'pyenv'? [y/N]: " 
    [[ "$REPLY" != "y" ]] && _err && return

    # otherwise install a 'pybrat' virtualenv in ~/.pybrat
    echo "Installing virtualenv for '${PYBRAT_DEF_ROOTD}' ..."
    exec pyenv virtualenv "${REQ_PYVER}" "${PYBRAT_PROG}"

    # make sure it worked
    pyvers="$(pyenv versions)"
    [[ "$pyvers" == *"$PYBRAT_PROG"* ]] && return

    # otherwise something went wrong
    echo "==> ERROR: virtualenv did not initialize correctly."
    _err; return
}



# check for required dependencies
function _check_requirements {
    # install and config pyenv if user wants
    _check_req_pyenv
    # use pyenv to boostrap req py ver if user wants
    [[ "$NOERR" != "0" ]] && return || _check_req_pyver
    # must have req python version for the rest, so return if not
    # deprecated but needed for migration to pyenv
    [[ "$NOERR" != "0" ]] && return || _check_req_brew
}



#### Command line option functions. ####

function _config_shrc_pybrat {

    echo; read -p "Configure 'pybrat' in your '~/.bashrc'? [y/N]: "
    if [[ "$REPLY" != "y" ]]; then
        printf "\n==>ERROR: 'pybrat' needs to be configured to work!\n"
        _err; return
    fi

    # write to !/.bashrc
    printf "\n# 'pybrat' environment configuration\n" \
        >> /home/${USER}/.bashrc
    echo "[[ -s ${HOME}/.pybrat/etc/bashrc ]] && source ${HOME}/.pybrat/etc/bashrc" >> /home/${USER}/.bashrc
    source "${PYBRAT_DEF_ROOTD}/etc/bashrc"
}


# shell based installer
function _run_shinstall {

    echo "Installing 'pybrat' ..."
    # make sure it's not already installed correctly
    if [[ -e "${PYBRAT_DEF_ROOTD}" ]] && [[ -e "${PYBRAT_DEF_COMMANDD}/pybrat" ]]; then
        echo "==> ERROR: PyBrat is already installed. Uninstall first."
        _err; return
    fi

    # make sure all dependencies satisfied fully
    _check_requirements

    if [[ "$NOERR" != "0" ]]; then
        echo "==> ERROR (${NOERR}): try after fixing (${NOERR}) problems."
        _err; return
    fi

    # then we can install the default '~/.pybrat' dir
    if [[ "$PWD" != "$PYBRAT_DEF_ROOTD" ]]; then
        # if not already in ~/.pybrat, then use setup.py to install the files
        echo "Running setup.py ..."
        if [ -e "./setup.py" ]; then
            python${PYBRAT_PYVER} setup.py install
        else
            echo "==> ERROR: 'setup.py' not found."
            _err; return
        fi
        # then change to install root dir
        cd ${PYBRAT_DEF_ROOTD}
    fi

    # then make the project links in '~/.config' (creating if not existent)
    if [ ! -e "$PYBRAT_DEF_PROJD" ]; then
        printf "Creating project links directory\n  --> $PYBRAT_DEF_PROJD\n"
        mkdir -p $PYBRAT_DEF_PROJD
    fi

    # now install the user command 
    echo "Creating 'pybrat' command link in ${PYBRAT_DEF_COMMANDD} ..."
    sudo ln -s "${PYBRAT_DEF_MAINF}" "${PYBRAT_DEF_COMMANDD}/pybrat"

    # now req perm to append user shell config script ie .bashrc
    _config_shrc_pybrat
}


# shell based uninstaller
function _run_shuninstall {

    echo "Uninstalling 'pybrat' ..."
    # make sure it's installed
    if [ -e ${PYBRAT_DEF_ROOTD} ]; then
        rm -rf "$PYBRAT_DEF_ROOTD"
        sudo rm "${PYBRAT_DEF_COMMANDD}/pybrat"
        echo "Done! Remove the 'pybrat' section from your '~/.bashrc' file."
    else
        echo "Not installed. Nothing to do."
    fi
}


# shell based delete
function _run_shdelete {

    echo "Deleting symbolic links to project directories ..."
    # make sure projects directory exists
    if [ -e ${PYBRAT_DEF_PROJD} ]; then
        rm -rf "$PYBRAT_DEF_PROJD"
    else
        echo "Project links directory not found. Nothing to do."
    fi
}


# help function
function _run_help {
    echo "usage: install [-h | -i | -r | -u | -d]"
    echo "See 'README.md' for more information."
}



#### main functions ####

# parse command line options

function _parse_opts {
    OPTIND=1
    while getopts "hirud" opt; do
        case "$opt" in
            h)
                _run_help
                exit 1
                ;;
            i)
                _run_shinstall
                exit $NOERR
                ;;
            r) 
                _run_shuninstall
                [[ "${NOERR}" ==  "0" ]] && _run_shinstall
                exit $NOERR
                ;;
            u)
                _run_shuninstall
                exit $NOERR
                ;;
            d)
                _run_shuninstall
                _run_shdelete
                exit $NOERR
                ;;
        esac
    done

    # otherwise spit out help
#    _run_help
#    exit 1
}


#===========================================#
#                    MAIN                   #
#===========================================#

OLDIFS=$IFS

source ./etc/util.sh                # get search & cfg utils
cfg_parser ./etc/pybrat.cfg         # parse 'pybrat.cfg'
cfg.section.pybrat                  # get global settings
#cfg_parser ./etc/pybrat.cfg
cfg.section.hacks                   # get hacks settings

# get the app-spec install-config vars & functions
IFS=' '
PYMGR_ARY=( `echo ${ALLOWED_PYMGRS[@]}` )
for hack in ${PYMGR_ARY[@]}; do
    source "./etc/hacks/${hack}.sh"
done

# split $PATH for search_path function
IFS=:
DIRS=
read DIRS <<END
$PATH
END

# parse command line options
_parse_opts $@

IFS=$OLDIFS

exit $NOERR
