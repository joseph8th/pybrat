#!/usr/bin/env bash

#***********************************#
# Shell-only installer/bootstrapper #
#***********************************#


#set -x

# globals
NOERR=0          # global number of errors logged
FIND_PATH=1      # global used by search_path util 
OPT_IN=0         # global code used by hacks installers



# Error logging
function _err {
    let NOERR=NOERR+1
}



# using only Python 2.7, for now ...
function _check_req_pyver {

    # see if correct virtualenv already set in pyenv
    local pyvers="$(pyenv versions)"
    [[ "$pyvers" == *"* $PYBRAT_PROG "* ]] && return

    # see if virtualenv in pyenv but not set to local
    if [[ "$pyvers" == *"$PYBRAT_PROG"* ]] && [[ -e "$PYBRAT_PROG" ]]; then
        pyenv shell --unset
        pyenv local $PYBRAT_PROG
        return
    fi

    # install required python version if not already installed
    if [[ "$pyvers" != *"${REQ_PYVER}"* ]]; then
        echo "==> 'pybrat' requires a 'pyenv virtualenv' with Python-${REQ_PYVER}."
        read -p "Bootstrap Python-${REQ_PYVER} with 'pyenv'? [y/N]: " 
        [[ "$REPLY" != "y" ]] && _err && return

        # otherwise install a 'pybrat' virtualenv in ~/.pybrat
        echo "Installing Python-${REQ_PYVER} with 'pyenv' ..."
        pyenv install ${REQ_PYVER}
        pyvers="$(pyenv versions)"
        [[ "$pyvers" != *"$REQ_PYVER"* ]] && _err && return
    fi

    echo "Installing virtualenv for '${PYBRAT_DEF_ROOTD}' ..."
    pyenv virtualenv "${REQ_PYVER}" "${PYBRAT_PROG}"
    pyvers="$(pyenv versions)"
    [[ "$pyvers" == *"$PYBRAT_PROG"* ]] && return

    # otherwise something went wrong
    _err; return
}



# check for required dependencies - intentional no auto-install of hacks
function _check_requirements {

    # install optional hacks
    _check_req_brew           # deprecated but maybe wanted for migration
#    _check_req_wrap           # if 
 
   # install and config pyenv if user wants
    [[ "$NOERR" != "0" ]] && return || _check_req_pyenv

    # use pyenv to boostrap req py ver if user wants
    [[ "$NOERR" != "0" ]] && return || _check_req_pyver
}



#### Command line option functions. ####

function _config_shrc_pybrat {

    [[ "$OPT_IN" != "1"* ]] && return 

    echo; read -p "Configure 'pybrat' for 'pythonbrew' in your '~/.bashrc'? [y/N]: "
    if [[ "$REPLY" != "y" ]]; then
        printf "\n==>ERROR: 'pybrat' needs to be configured to work!\n"
        _err; return
    fi

    # write to !/.bashrc
    printf "\n# 'pybrat' environment configuration\n" \
        >> /home/${USER}/.bashrc
    echo "[[ -s ${HOME}/.pybrat/etc/bashrc ]] && source ${HOME}/.pybrat/etc/bashrc" >> /home/${USER}/.bashrc
    source "${PYBRAT_DEF_ROOTD}/etc/bashrc"
}


# shell based installer
function _run_shinstall {

    echo "Installing 'pybrat' ..."
    # make sure it's not already installed correctly
    if [[ -e "${PYBRAT_DEF_ROOTD}" ]] && [[ -e "${PYBRAT_DEF_COMMANDD}/pybrat" ]]; then
        echo "==> ERROR: PyBrat is already installed. Uninstall first."
        _err; return
    fi

    # make sure all dependencies satisfied fully
    _check_requirements

    if [[ "$NOERR" != "0" ]]; then
        echo "==> ERROR (${NOERR}): try after fixing (${NOERR}) problems."
        _err; return
    fi

    pyenv shell $PYBRAT_PROG        # switch the shell to our virtualenv

    # then we can install the default '~/.pybrat' dir
    if [[ "$PWD" != "$PYBRAT_DEF_ROOTD" ]]; then

        echo "Running 'setup.py' ..."
        # if not already in ~/.pybrat, then use setup.py to install the files
        if [ -e "./setup.py" ]; then
            python setup.py install
        else
            echo "==> ERROR: 'setup.py' not found."
            _err; return
        fi

        cd ${PYBRAT_DEF_ROOTD}          # then change to install root dir
    fi

    # and set the local python to our virtualenv
    pyenv shell --unset
    pyenv local $PYBRAT_PROG

    # then make the project links in '~/.config' (creating if not existent)
    if [ ! -e "$PYBRAT_DEF_PROJD" ]; then
        printf "Creating project links directory\n  --> $PYBRAT_DEF_PROJD\n"
        mkdir -p $PYBRAT_DEF_PROJD
    fi

    # now install the user command 
    echo "Creating 'pybrat' command link in ${PYBRAT_DEF_COMMANDD} ..."
    sudo ln -s "${PYBRAT_DEF_MAINF}" "${PYBRAT_DEF_COMMANDD}/pybrat"

    # now request permission to append user shell config script ie .bashrc
    _config_shrc_pybrat
}


# shell based uninstaller
function _run_shuninstall {

    echo "Uninstalling 'pybrat' ..."
    # make sure it's installed
    if [ -e ${PYBRAT_DEF_ROOTD} ]; then
        cd "$HOME"
        rm -rf "$PYBRAT_DEF_ROOTD"
        sudo rm "${PYBRAT_DEF_COMMANDD}/pybrat"
        echo "Done! Remove the 'pybrat' section from your '~/.bashrc' file."
    else
        echo "Not installed. Nothing to do."
    fi
}


# shell based delete
function _run_shdelete {

    echo "Deleting symbolic links to project directories ..."
    # make sure projects directory exists
    if [ -e ${PYBRAT_DEF_PROJD} ]; then
        rm -rf "$PYBRAT_DEF_PROJD"
    else
        echo "Project links directory not found. Nothing to do."
    fi
}


# help function
function _run_help {
    echo "usage: manage [-h | -i | -r | -u | -d]"
    echo "See 'README.md' for more information."
}



#### main functions ####

# parse command line options

function _parse_opts {
    OPTIND=1
    while getopts "hirud" opt; do
        case "$opt" in
            h)
                _run_help
                exit 1
                ;;
            i)
                _run_shinstall
                exit $NOERR
                ;;
            r) 
                _run_shuninstall
                [[ "${NOERR}" ==  "0" ]] && _run_shinstall
                exit $NOERR
                ;;
            u)
                _run_shuninstall
                exit $NOERR
                ;;
            d)
                _run_shuninstall
                _run_shdelete
                exit $NOERR
                ;;
        esac
    done
}


#===========================================#
#                    MAIN                   #
#===========================================#

OLDIFS=$IFS
PYBRAT_CFGF=./etc/pybrat.cfg

source ./etc/util.sh                # get search & cfg utils

cfg_parser $PYBRAT_CFGF         # parse 'pybrat.cfg'
cfg.section.pybrat                  # get global settings
cfg.section.hacks                   # get hacks settings

# get the app-spec install-config vars & functions

IFS=' '
ALLOWED_PYMGR_ARY=( `echo ${ALLOWED_PYMGRS[@]}` )
for pymgr in ${ALLOWED_PYMGR_ARY[@]}; do
    source "./etc/hacks/${pymgr}.sh"
done

# split $PATH for search_path function
IFS=:
DIRS=
read DIRS <<END
$PATH
END

# parse & run command line options
_parse_opts $@

IFS=$OLDIFS

exit $NOERR
